> 参考：https://blog.csdn.net/apple_wolf/article/details/81331475


### 继承
接口是常量值和方法定义的集合。接口是一种特殊的抽象类。
 
java类是单继承的。classB Extends classA
java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……

不允许类多重继承的主要原因是，如果A同时继承B和C，而b和c同时有一个D方法，A如何决定该继承那一个呢？  
但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。
 

注意：   
1）一个类如果实现了一个接口，则要实现该接口的所有方法。  
2）方法的名字、返回类型、参数必须与接口中完全一致。如果方法的返回类型不是void，则方法体必须至少有一条return语句。  
3）因为接口的方法默认是public类型的，所以在实现的时候一定要用public来修饰（否则默认为protected类型，缩小了方法的使用范围）。

### volatile关键字
#### volatile是synchronized的一种弱实现，它可以保证变量的可见性，而不能保证程序执行的原子性。
#### volatile是synchronized的一种弱实现，它可以保证变量的可见性，而不能保证程序执行的原子性。JVM运行多线程时，在主内存中保存着共享变量，每个线程运行时有一个自己的栈，用来保存从本线程运行需要的变量。当线程访问一个变量值的时候，首先通过对象的引用找到在主内存的地址，然后把变量的值拷贝到本线程的栈中，建立一个变量的副本。在线程对该变量计算的过程中，该变量副本和主内存的原始变量就没有任何关系了，当线程结算结束时，再将变量副本写回到主内存中对象变量的地址中，更新内存中的共享变量，详细的交互过程如下图所示。
![线程工作内存与主内存](https://images0.cnblogs.com/blog/206865/201401/191326344702.jpg)
#### 使用volatile修饰的变量，JVM只能保证从主内存加载到线程工作栈中的值是最新的，但使用过程不能完全保证线程对该变量同步的情况，因此，建议少使用volatile，对需要同步的地方使用synchronized。